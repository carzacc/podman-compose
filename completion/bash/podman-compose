# all functions will return 0 if they successfully complete the argument
# (or establish there is no need or no way to complete), and something
# other than 0 if that's not the case

_completeGlobalOptArgs() {
    # arguments to options that take paths as arguments: complete paths
    for el in ${path_arg_global_opts}; do
        if [[ ${prev} == ${el} ]]; then
            COMPREPLY=( $(compgen -f -- ${cur}) )
            return 0
        fi
    done

    # computing comp_cword_adj, which thruthfully tells us how deep in the subcommands tree we are
    for el in ${generic_arg_global_opts}; do
        if [[ ${prev} == ${el} ]]; then
            return 0
        fi
    done
    return 1
}

_completeRoot() {
    # if we're completing an option
    if [[ ${cur} == -* ]]; then
        COMPREPLY=( $(compgen -W "${global_opts}" -- ${cur}) )
        return 0
    fi
    # complete root commands
    COMPREPLY=( $(compgen -W "${root_commands}" -- ${cur}) )
    return 0
}

_completeServiceNames() {
    # ideally we should complete service names,
    # but parsing the compose spec file in the
    # completion script is quite complex
    return 0
}


# complete the arguments for `podman-compose up` and return 0
_completeUpArgs() {
    up_opts="${help_opts} -d --detach --no-color --quiet-pull --no-deps --force-recreate --always-recreate-deps --no-recreate --no-build --no-start --build --abort-on-container-exit -t --timeout -V --renew-anon-volumes --remove-orphans --scale --exit-code-from --pull --pull-always --build-arg --no-cache"
    if [[ ${prev} == "--scale" || ${prev} == "-t" || ${prev} == "--timeout" ]]; then
        return 0
    elif [[ ${cur} == -* ]]; then
        COMPREPLY=( $(compgen -W "${up_opts}" -- ${cur}) )
        return 0
    else
        _completeServiceNames
        if [[ $? -eq 0 ]]; then
            return 0
        fi
        return 0
    fi

}




_podmanCompose() {
    cur="${COMP_WORDS[COMP_CWORD]}"
	prev="${COMP_WORDS[COMP_CWORD-1]}"
    root_commands="help version pull push build up down ps run exec start stop restart logs"
    # global options that don't take additional arguments
    basic_global_opts="-h --help -v --no-ansi --no-cleanup --dry-run" 
    # global options that take paths as arguments
    path_arg_global_opts="-f --file --podman-path"
    path_arg_global_opts_array=($arg_global_opts)
    # global options that take arguments that are not files
    generic_arg_global_opts="-p --project-name --podman-path --podman-args --podman-pull-args --podman-push-args --podman-build-args --podman-inspect-args --podman-run-args --podman-start-args --podman-stop-args --podman-rm-args --podman-volume-args"
    generic_arg_global_opts_array=($generic_arg_global_opts)
    arg_global_opts="${path_arg_global_opts} ${generic_arg_global_opts}"
    arg_global_opts_array=($arg_global_opts)
    global_opts="${basic_global_opts} ${arg_global_opts}"

    chosen_root_command=""


    _completeGlobalOptArgs
    if [[ $? -eq 0 ]]; then
        return 0
    fi
   
    # computing comp_cword_adj, which thruthfully tells us how deep in the subcommands tree we are
    # additionally, set the chosen_root_command if possible
    comp_cword_adj=${COMP_CWORD}
    if [[ ${COMP_CWORD} -ge 2 ]]; then
        skip_next="no"
        for el in ${COMP_WORDS[@]}; do
            if [[ ${skip_next} == "yes" ]]; then
                let "comp_cword_adj--"
                skip_next="no"
                continue
            fi
            if [[ ${el} == -* && ${el} != ${cur} ]]; then
                let "comp_cword_adj--"
                
                for opt in ${arg_global_opts_array[@]}; do
                    if [[ ${el} == ${opt} ]]; then
                        skip_next="yes"
                    fi
                done
            elif [[ ${el} != ${cur} && ${el} != ${COMP_WORDS[0]} && ${chosen_root_command} == "" ]]; then
                chosen_root_command=${el}
            fi
        done
    fi
    
    if [[ ${comp_cword_adj} -eq 1 ]]; then
       _completeRoot

       # Given that we check the value of comp_cword_adj outside
       # of it, at the moment _completeRoot should always return
       # 0, this is just here in case changes are made. The same
       # will apply to similar functions below
        if [[ $? -eq 0 ]]; then
            return 0
        fi
    fi
    case $chosen_root_command in
        up)
            _completeUpArgs
            if [[ $? -eq 0 ]]; then
                return 0
            fi
            ;;
        exec)
            if [[ ${comp_cword_adj} -eq 2 ]]; then
                return 0
            fi
    esac
    echo unsupported
}

complete -F _podmanCompose podman-compose